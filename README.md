# problemsolving
풀었던 문제들을 정리하지 않았더니 자꾸 까먹기도 하고 해서 이후로는 풀면서 기록하기로 하였습니다.

## 백준
- 1003
  - 재귀로 피보나치를 푸는 방식과 비슷하게 풀 수 있다.
  - 0일때 1,0 1일때 0,1을 리턴하고 그외엔 재귀호출을 이용한다.
  - 이때 메모제이션 기법을 사용, 이전에 사용한것을 메모한다.
  - N이 40 이하이므로 애초에 41개를 계산하고 리턴해도 될듯하다.
- 13460
  - BFS 사용
  - 각 계층에서 가능한 모든 움직임을 계산한후 다음 계층으로 추가
  - 이때 먼저 움직일 공을 결정하고 이를 이용
  - python의 얕은 복사를 활용
  - 이전 단계와 동일한 위치에 구슬두개가 있을경우 해당 가지는 삭제 (이걸로 4배 빨라짐)
  - 고생한것 : 이전 단계에서 진행한 방향을 다음 단계에서 다시 할 필요가 없어서 method 변수를 추가했는데, continue로 반복문을
  넘길때 method += 1을 깜박해서 이걸로 1시간동안 찾음.. 좀 더 신경쓰자
## SWEA
- 2819
  - DFS, Memoization
  - 특정 격자에 있을때의 숫자를 저장한다. 이후 해당 격자에 도착했을때 숫자가 동일하면 cut.
- 4112
  - 특정 숫자가 주어졌을때 피라미트 층수와 호수를 구한다 (층은 1이 1부터 시작 내려갈수록 커짐, 호는 좌측이 1)
  - 특정층i1 의 특정호j1 에서 출발해서 내려갈때, 도착하는 위치의 호(j2)에 따라서 계산이 달라짐.
  - 이때 i1 < i2이라고 가정하고 품. (테스트 케이스에서는 도착층이 더 낮을경우도 있을것임. 
  하지만 이경우 둘을 뒤집는다. 이게 생각하기 편했음)
  - case 1. j2<j1 : 이때는 층을 다 내려온뒤 j1-j2만큼 더 이동해야함
  - case 2. j1 < j2 < j1+i2-i1 : 이때는 층을 내려가기만 하면 도착 가능함
  - case 3. j1+i2-i1 < j2 : 이때는 층을 내려온뒤 오른쪽으로 더 가야함. 이때 최종 계산은 i2-i1+j2-j1-i2+i1 = j2-j1이 됨.
  - 개념적인 해설 -> 특정 위치에서 출발해서 내려갈때 층 내려가는것만으로 도착가능한 범위는 출발위치에서 삼각형으로 내려감. 
  이때 삼각형 범위를 벗어나는 도착점을 가기 위해서는 해당 층에 도착한뒤(이건 삼각형의 꼭지점이 될것임)거기서 좌우로 추가로 
  이동해야함.
  - case 3에서 j만 가지고 계산이 가능한 이유는 내려가는동안에도 j가 계속해서 증가하기 때문.